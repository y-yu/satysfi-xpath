@require: list
@import: util
@import: curve
@import: graph
@import: rail

open XPathUtil
type rail = XPathRail.t

module XPath : sig
    type t
    type pre

    % SATySFi compatible APIs
    val unite-path : t -> t -> t
    val shift-path : point -> t -> t
    val linear-transform-path : float -> float -> float -> float -> t -> t
    val get-path-bbox : t -> point * point
    val start-path : point -> pre
    val line-to : point -> pre -> pre
    val bezier-to : point -> point -> point -> pre -> pre
    val terminate-path : pre -> t
    val close-with-line : pre -> t
    val close-with-bezier : point -> point -> pre -> t
    val stroke : length -> color -> t -> graphics
    val fill : color -> t -> graphics
    val dashed-stroke : length -> length * length * length -> color -> t -> graphics

    % conversion
    val to-embedded-path : t -> path
    val to-embedded-prepath : pre -> pre-path
    val into-graph : t -> XPathGraph.t

    val remove-inner-edges : delta -> t -> t

    % path transformation functions
    % val outset-path : length -> t -> t
    % val inset-path : length -> t -> t
    % val simplify-path : float -> t -> t
    % val deformation-by-path : t -> t -> t
    % val deformation-by-func : (point -> point) -> t -> t

    % path composition functions
    % val outline-of-path : length -> t -> t
    % val outline-of-path-with-func : (length -> (length * length) option) -> t -> t
    % val make-union-of-paths : t -> t -> t
    % val make-intersection-of-paths : t -> t -> t
    % val make-difference-of-paths : t -> t -> t
    % val make-exclusion-of-paths : t -> t -> t
    % val make-division-of-paths : t -> t -> t
    % val make-cut-of-paths : t -> t -> t
    % val combine-paths : t -> t -> t
    % val break-apart-paths : t -> t -> t

    % analyzing functions
    % val get-cross-points : t -> t -> point * float list
    % val get-length-of-path : t -> length
    % val get-passing-point : float -> t -> point * float
    % val get-area-level : point -> t -> int
    % val get-enclosing-path : point -> t -> t

    val get-intersections : length -> t -> point list
    val get-intersections-between : length -> t -> t -> point list

end = struct

    type pre = PrePoint of point | PreRail of rail
    type t = pre list

    % let as-curves pth = pth |> List.concat
    % let as-curves-all pth = pth |> List.map (fun lst -> (
    %     match lst with
    %     | [] -> []
    %     | head :: rs ->
    %           let tail = match list-last rs with
    %               | None -> head
    %               | Some(tail) -> tail
    %           in
    %           let (p0, _, _, _) = XPathCurve.as-controls head in
    %           let (_, _, _, p1) = XPathCurve.as-controls tail in
    %           if p0 =.. p1 then lst
    %             else
    %                 [XPathCurve.from-controls (p1, p1, p0, p0)] |> List.append lst
    %     ))


    % let get-intersections-internal delta pth =
    %     let lst = as-curves-all pth in
    %     lst |> List.mapi (fun li cli -> (
    %         lst |> List.mapi (fun lj clj -> (
    %             if li <= lj then
    %                 cli |> List.mapi (fun i ci -> (
    %                     clj |> List.mapi (fun j cj -> (
    %                         let ei = delta /' (XPathCurve.get-simple-norm ci) in
    %                         let ej = delta /' (XPathCurve.get-simple-norm cj) in
    %                         if i > j then []
    %                         else if li == lj then
    %                             let max = List.length cli - 1 in
    %                             if i == 0 && j == max then
    %                                 if max <= 1 then
    %                                     XPathCurve.get-self-intersects delta ci
    %                                         |> List.filter (fun (u, v) -> (
    %                                             not (
    %                                                 (float-abs (v -. 1.) <. ej &&
    %                                                 float-abs u <. ei) ||
    %                                                 (float-abs (u -. 1.) <. ei &&
    %                                                 float-abs v <. ej)
    %                                             )
    %                                         ))
    %                                         |> List.map (XPathCurve.get-point-from-curves-and-pos ci cj)
    %                                 else
    %                                     XPathCurve.get-intersects delta ci cj
    %                                         |> List.filter (fun (u, v) -> (
    %                                         not (float-abs (v -. 1.) <. ej &&
    %                                             float-abs u <. ei)
    %                                         ))
    %                                         |> List.map (XPathCurve.get-point-from-curves-and-pos ci cj)
    %                             else if i == j then
    %                                 XPathCurve.get-self-intersections delta ci
    %                             else if i + 1 == j then
    %                                 XPathCurve.get-intersects delta ci cj
    %                                     |> List.filter (fun (u, v) -> (
    %                                     not (float-abs (u -. 1.) <. ei &&
    %                                         float-abs v <. ej)
    %                                     ))
    %                                     |> List.map(XPathCurve.get-point-from-curves-and-pos ci cj)
    %                             else
    %                                 XPathCurve.get-intersections delta ci cj
    %                         else
    %                             XPathCurve.get-intersections delta ci cj
    %                     )) |> List.concat
    %                 )) |> List.concat
    %             else
    %                 []
    %         )) |> List.concat
    %     )) |> List.concat


    let to-embedded-prepath pp =
        match pp with
        | PrePoint(p0) -> start-path p0
        | PreRail(r) ->
              let (p0, lst) = XPathRail.into-list r in
              lst |> List.fold-left (fun ret (item, p3) -> (
                  match item with
                  | None -> ret |> line-to p3
                  | Some((p1, p2)) -> ret |> bezier-to p1 p2 p3
              )) (start-path p0)


    let to-embedded-path pat =
        match pat with
        | [] -> display-message `ERROR in to-embedded-path` before
              start-path (0pt, 0pt) |> terminate-path
        | pp0::pps -> pps |> List.fold-left (fun ret pp -> (
              to-embedded-prepath pp |> terminate-path |> unite-path ret
        )) (to-embedded-prepath pp0 |> terminate-path)


    let into-graph pat =
        pat |> List.fold-left (fun ret pp -> (
            match pp with
            | PrePoint(_) -> ret
            | PreRail(r) -> XPathGraph.add-rail r ret
        )) (XPathGraph.new)


    let get-intersections delta pat =
        into-graph pat |> XPathGraph.as-points


    let remove-inner-edges delta pat =
        into-graph pat |> XPathGraph.remove-inner-edges
                       |> into-closed-rails
                       |> List.map (fun r -> PreRail(r))


    % SATySFi compatible APIs

    let unite-path = List.append
    let start-path p = PrePoint(p)
    let terminate-path pp = [pp]


    let shift-path v = List.map (fun pp -> (
        match pp with
        | PrePoint(p) -> PrePoint(p +.. v)
        | PreRail(r) -> PreRail(XPathRail.shift v r)
    ))


    let line-to p pp = match pp with
        | PrePoint(p0) -> PreRail(
              XPathRail.from-curve (XPathCurve.from-controls (p0, p0, p, p)))
        | PreRail(r) -> PreRail(XPathRail.line-to p r)


    let bezier-to p1 p2 p pp = match pp with
        | PrePoint(p0) -> PreRail(
              XPathRail.from-curve (XPathCurve.from-controls (p0, p1, p2, p)))
        | PreRail(r) -> PreRail(XPathRail.bezier-to p1 p2 p r)


    let close-with-line pp = match pp with
        | PrePoint(p0) -> PrePoint(p0)
        | PreRail(r) -> PreRail(XPathRail.close r)


    let close-with-bezier p1 p2 pp = match pp with
        | PrePoint(p0) -> PreRail(XPathRail.from-controls (p0, p1, p2, p0))
        | PreRail(r) -> PreRail(XPathRail.close-with-bezier p1 p2 r)


    let stroke l color pat = to-embedded-path pat |> stroke l color
    let fill color pat = to-embedded-path pat |> fill  color
    let dashed-stroke l (l1, l2, l3) color pat = to-embedded-path pat |> dashed-stroke l (l1, l2, l3) color
    let get-path-bbox pat = to-embedded-path pat |> get-path-bbox
    let linear-transform-path a b c d pat =
        pat |> List.map (fun pp -> (
            match pp with
            | PrePoint(p0) ->
                  let (x, y) = p0 in
                  PrePoint((x *' a +' y *' b, x *' c +' y *' d))
            | PreRail(r) -> PreRail(XPathRail.linear-transform (a, b, c, d) r)
        ))
end
