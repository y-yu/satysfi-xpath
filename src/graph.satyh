@require: list
@import: util
@import: curve
@import: rail

open XPathUtil

type curve = XPathCurve.t
type rail = XPathRail.t
type loc = XPathRail.loc

% Representation of graph-like structure of rails
module XPathGraph : sig

    type t

    val new : t
    val as-points : t -> point list
    val as-rails : t -> rail list

    val add-rail : length -> rail -> t -> t
    val remove-inner-edges : t -> t
    val into-closed-rails : t -> rail list

end = struct
    type t = (curve list) list * (point list)

    let new = ([], [])
    let as-points (_, lst) = lst
    let as-all-curves (lst, _) =
        lst |> List.concat


    let-rec get-point (i, u) cs =
        match cs with
        | [] ->
             display-message `ERROR in get-point` before
             (0pt, 0pt) % ERROR
        | c::cs ->
              if i == 0 then
                  XPathCurve.get-point u c
              else
                  get-point (i - 1, u) cs
        

    % items should be sorted
    let add-sorted items lst =
        let (res, items) = lst |> List.fold-right (fun (j, v, pj) (res, items) -> (
            let (res, items) = items |> List.fold-right (fun (i, u, pi) (res, items) -> (
                if j < i || (i == j && v <. u) then
                    ((i, u, pi) :: res, items)
                else
                    (res, (i, u, pi) :: items)
            )) (res, [])  in
            ((j, v, pj) :: res, items)
        )) ([], items) in
        List.append items res


    let get-cross-points-self delta cs =
        cs |> List.fold-lefti (fun i ret ci -> (
            cs |> List.fold-lefti (fun j ret cj -> (
                let ei = delta /' (XPathCurve.get-simple-norm ci) in
                let ej = delta /' (XPathCurve.get-simple-norm cj) in
                if i > j then ret
                else
                    let max = List.length cs - 1 in
                    if i == 0 && j == max then
                        if max <= 1 then
                            XPathCurve.get-self-intersects delta ci
                                |> List.fold-right (fun (u, v) ret -> (
                                    if (
                                        (float-abs (v -. 1.) <. ej &&
                                        float-abs u <. ei) ||
                                        (float-abs (u -. 1.) <. ei &&
                                        float-abs v <. ej)
                                    ) then ret
                                    else
                                        let pi = XPathCurve.get-point u ci in
                                        let pj = XPathCurve.get-point v cj in
                                        let p = (pi +.. pj) *.. 0.5 in
                                        ret |> add-sorted (
                                            if i < j || u <=. v then
                                                [(i, u, p); (j, v, p)]
                                            else
                                                [(j, v, p); (i, u, p)]
                                        )
                                )) ret
                        else
                            XPathCurve.get-intersects delta ci cj
                                |> List.fold-right (fun (u, v) ret -> (
                                    if (float-abs (v -. 1.) <. ej &&
                                        float-abs u <. ei)
                                    then ret
                                    else
                                        let pi = XPathCurve.get-point u ci in
                                        let pj = XPathCurve.get-point v cj in
                                        let p = (pi +.. pj) *.. 0.5 in
                                        ret |> add-sorted [(i, u, p); (j, v, p)]
                                )) ret
                    else if i == j then
                        XPathCurve.get-self-intersects delta ci
                            |> List.fold-right (fun (u, v) ret -> (
                                let pi = XPathCurve.get-point u ci in
                                let pj = XPathCurve.get-point v cj in
                                let p = (pi +.. pj) *.. 0.5 in
                                ret |> add-sorted (
                                    if u <=. v then
                                        [(i, u, p); (j, v, p)]
                                    else
                                        [(j, v, p); (i, u, p)]
                                )
                            )) ret
                    else if i + 1 == j then
                        XPathCurve.get-intersects delta ci cj
                            |> List.fold-right (fun (u, v) ret -> (
                                if (float-abs (u -. 1.) <. ei &&
                                    float-abs v <. ej)
                                then ret
                                else
                                    let pi = XPathCurve.get-point u ci in
                                    let pj = XPathCurve.get-point v cj in
                                    let p = (pi +.. pj) *.. 0.5 in
                                    ret |> add-sorted [(i, u, p); (j, v, p)]
                            )) ret
                    else
                        XPathCurve.get-intersects delta ci cj
                            |> List.fold-right (fun (u, v) ret -> (
                                let pi = XPathCurve.get-point u ci in
                                let pj = XPathCurve.get-point v cj in
                                let p = (pi +.. pj) *.. 0.5 in
                                ret |> add-sorted [(i, u, p); (j, v, p)]
                            )) ret
            )) ret
        )) []


    let get-cross-points delta cs1 cs2 =
        cs1 |> List.fold-lefti (fun i rs ci -> (
            cs2 |> List.fold-lefti (fun j rs cj -> (
                XPathCurve.get-intersects delta ci cj
                    |> List.fold-right (fun (u, v) (rs1, rs2) -> (
                        let pi = XPathCurve.get-point u ci in
                        let pj = XPathCurve.get-point v cj in
                        let p = (pi +.. pj) *.. 0.5 in
                        (
                            rs1 |> add-sorted [(i, u, p)],
                            rs2 |> add-sorted [(j, v, p)]
                        )
                    )) rs
            )) rs
        )) ([], [])


    % pts should be sorted
    let break-curves delta pts cs =
        let p0 = match cs with
            | [] -> display-message `ERROR in break-curve` before (0pt, 0pt)
            | c0 :: _ -> let (p0, _) = XPathCurve.as-edges c0 in p0
        in
        let (i, u, p0, ret) = pts |> List.fold-left (fun (i, u, p0, ret) (j, v, p) -> (
            let res = cs |> List.fold-lefti (fun k res c -> (
                if k < i || j < k then res
                else if k == i then
                    if i == j then
                        let l = XPathCurve.get-simple-norm c in
                        if float-abs (u -. v) <. delta /' l then
                            []
                        else
                            let (_, p1, p2, _) = XPathCurve.split-span u v c
                                |> XPathCurve.as-controls in
                            [XPathCurve.from-controls (p0, p1, p2, p)]
                    else
                        let (_, c) = XPathCurve.split-at u c in
                        let (_, p1, p2, p3) = XPathCurve.as-controls c in
                        [XPathCurve.from-controls (p0, p1, p2, p3)]
                else if k == j then
                    let (c, _) = XPathCurve.split-at v c in
                    let (p0, p1, p2, _) = XPathCurve.as-controls c in
                    List.append res [XPathCurve.from-controls (p0, p1, p2, p)]
                else
                    List.append res [c]
            )) [] in
            (j, v, p0, List.append ret [res])
        )) (0, 0. , p0, [] ) in
        let res = cs |> List.fold-lefti (fun k res c -> (
            if i == k then
                let (_, c) = XPathCurve.split-at u c in
                let (_, p1, p2, p3) = XPathCurve.as-controls c in
                List.append res 
                    [XPathCurve.from-controls (p0, p1, p2, p3)]
            else if i < k then
                List.append res [c]
            else []
        )) [] in
        List.append ret [res]


    let-rec get-neighborhood-point delta pt pts =
        match pts with
        | [] -> None
        | p :: pts ->
              if point-norm (p -.. pt) <' delta then
                  Some(p)
              else
                  get-neighborhood-point delta pt pts


    let fix-positions delta ps pts =
        ps |> List.fold-left (fun (ps, pts) (i, u, p) -> (
            match get-neighborhood-point delta p pts with
            | None -> ((i, u, p) :: ps, p :: pts)
            | Some(p) -> ((i, u, p) :: ps, pts)
        )) ([], pts)


    let add-closed-curves delta cs (lst, pts) =
        let ps = get-cross-points-self delta cs in
        let (ps, pts) = fix-positions delta ps pts in
        let (lst, pts, ps) = lst |> List.fold-right (fun cs2 (lst, pts, ps) -> (
            let (ps1, ps2) = get-cross-points delta cs cs2 in
            let (ps1, pts) = fix-positions delta ps1 pts in
            let (ps2, pts) = fix-positions delta ps2 pts in
            let lst2 = break-curves delta ps2 cs2 in
            (List.append lst2 lst, pts, add-sorted ps1 ps)
        )) (lst, pts, ps) in
        let lst2 = break-curves delta ps cs in
        %hazi
        (List.append lst lst2, pts)


    let get-first-curve lst =
        match lst with
        | [] -> display-message `ERROR in get-last-inv-curve` before
              XPathCurve.nil
        | item :: _ -> item


    let-rec get-last-inv-curve lst =
        match lst with
        | [] -> display-message `ERROR in get-last-inv-curve` before
              XPathCurve.nil
        | item :: [] -> XPathCurve.inverse item
        | _ :: lst -> get-last-inv-curve lst


    let point-in-field p (lst, _) =
        let (clst, llst) = lst |> List.fold-lefti (fun i (clst, llst) cs -> (
            let c1 = get-first-curve cs in
            let c2 = get-last-inv-curve cs in
            match (p =.. XPathCurve.as-head c1, p =.. XPathCurve.as-head c2) with
            | (true, true) -> (c1 :: c2 :: clst, llst)
            | (true, false) -> (c1 :: clst, llst)
            | (false, true) -> (c2 :: clst, llst)
            | _ -> (clst, i :: llst)
        )) ([], []) in
        let alst = clst |> List.map (fun c -> (
            point-to-angle (XPathCurve.get-derivative 0. c)
        )) in
        let alst = match alst with
        | [] -> [0.]
        | at :: [] -> display-message `ERROR in point-in-field` before
              [float-mod (at +. pi) (2. *. pi)]
        | _ -> (
              match (alst |> float-sort) with
              | [] -> display-message `ERROR in point-in-field` before
                    [0.]
              | at0 :: alst ->
                    let (res, at) = alst |> List.fold-left (fun (acc, at0) at -> (
                        ((at +. at0) /. 2.) :: acc,
                        at
                    )) ([], at0) in
                    ((at +. at0) /. 2.) :: res
        ) in
        let (cin, cout) = alst |> List.fold-left (fun (cin, cout) at -> (
            let pv = angle-to-point 1cm at in
            let pe = p +.. pv in
            let pv = point-perp pv in
            let (n, _) = lst |> List.fold-lefti (fun j (acc, llst) cs -> (
                match llst with
                | [] -> (acc, [])
                | i :: llst ->
                      if i == j then
                          let acc = cs |> List.fold-left (fun acc c -> (
                              XPathCurve.get-lineseg-intersects (p, pe) c 
                                  |> List.fold-left (fun acc (u, v) -> (
                                    if u >. 0. then
                                        let qv = XPathCurve.get-derivative v c in
                                        if point-divide pv qv <' 0pt then
                                            acc + 1
                                        else % TODO: == 0pt case
                                            acc - 1
                                    else
                                        acc
                                  )) acc
                          )) acc in
                          (acc, llst)
                      else (acc, i :: llst)
            )) (0, llst) in
            if n == 0 then
                (cin, cout + 1)
            else
                (cin + 1, cout)
        )) (0, 0) in
        if cin == 0 then Some(false)
        else if cout == 0 then Some(true)
        else None


    let remove-inner-edges (lst, pts) =
        let (pts, delpts) = pts |> List.fold-right (fun p (pts, delpts) -> (
            match point-in-field p (lst, pts) with
            | Some(_) -> (pts, p :: delpts)
            | None -> (p :: pts, delpts)
        )) ([], []) in
        let llst = delpts |> List.fold-left (fun acc p -> ( % get touched lines with point
            lst |> List.fold-lefti (fun i acc cs -> (
                let c1 = get-first-curve cs in
                let c2 = get-last-inv-curve cs in
                if p =.. XPathCurve.as-head c1 || p =.. XPathCurve.as-head c2 then
                    let-rec add-num i lst =
                        match lst with
                        | [] -> [i]
                        | n0 :: ns ->
                              if i < n0 then i :: lst
                              else if i == n0 then lst
                              else n0 :: (add-num i ns)
                    in
                    add-num i acc
                else acc
            )) acc
        )) [] in
        let (lst, _) = lst |> List.fold-lefti (fun i (acc, llst) item -> (
            match llst with
            | [] -> (List.append acc [item], [])
            | j :: rm -> if i == j then (acc, rm) else (List.append acc [item], llst)
        )) ([], llst) in
        (lst, pts)


    let-rec get-edge-points lst = match lst with
        | [] -> display-message `ERROR in get-points` before ((0pt, 0pt), (0pt, 0pt))
        | c::[] -> XPathCurve.get-edges c
        | c::cs ->
              let (_, pe) = get-edge-points cs in
              let (pa, _) = XPathCurve.get-edges c in
              (pa, pe)


    let into-closed-curves (lst, _) =
        % Build a curve list which begins with p
        let impl p lst =
            let-rec impl-inner p-end p lst =
                let (pe, cs, lst) = lst |> List.fold-right (fun cs (pacc, csacc, lst) -> (
                    let (pa, pe) = get-edge-points cs in
                    if pa =.. pacc  && (List.length csacc == 0 || pa !=.. p) then
                        (pe, List.append csacc cs, lst)
                    else
                        (pacc, csacc, cs::lst)
                )) (p, [], []) in
                match cs with
                | [] -> ([], lst)
                | _ -> (
                      if p-end =.. pe then
                          (cs, lst)
                      else
                          let (cs2, lst0) = impl-inner p-end pe lst in
                          match cs2 with
                          | [] -> display-message `ERROR in into-closed-curves` before ([], lst)
                          | _ -> (List.append cs cs2, lst0)
                )
            in
            let (cs, lst) = impl-inner p p lst in


                      





end
